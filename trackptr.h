

#ifndef TRACKPTR_H
#define TRACKPTR_H

#include <stdint.h>


#if __WORDSIZE == 64
    typedef unsigned long int addr64_t;
    typedef addr64_t addr_t;
#else
    typedef unsigned long int addr32_t;
    typedef addr32_t addr_t;
#endif /* __WORDSIZE */

typedef addr_t ptr_id_t;



/*
 * возможные значения флага, с которым может инициализироваться структура track_ptr_t
 */
#define TRACK_FLAGS_NOT_SET         ( 0x0 )
#define TRACK_FLAG_ADDR_PROTECT     ( 0x2 )
#define TRACK_FLAG_ADDR_CHECK_SUM   ( 0x4 )



#define TRACK_CHECK_IS_FLAG(fset, f) ( ( fset & f ) != 0 )


#define TRACK_PTR(ptrack)       ( (void *)( *( (addr_t *)( (char *)(ptrack->__tptr) + 24 ) ) ) )
#define TRACK_INC(ptrack)       ( track_ptr_move(ptrack,  ptrack->iter_step) )
#define TRACK_DEC(ptrack)       ( track_ptr_move(ptrack, -(ptrack->iter_step)) )
#define TRACK_ADD(ptrack, n)    ( track_ptr_move(ptrack,  n) )

/* временное определение */
#define TEST_PTR_ACCESS


extern int errtrack;



/* структура, с через которую будет работать пользователь */
typedef struct {


    /*
     * идентификатор структуры указателя, через который
     * пользователь всегда сможет найти саму структуру
     * в общем списке, и получить информацию о ней
     */
    ptr_id_t ptrid;


    /*
     * указатель на данные, хранящиеся в узле списка, в котором хранятся все
     * когда-либо выделенные структуры (и выделенная память)
     */
    void *__tptr;

#ifdef TEST_PTR_ACCESS
    void *test_ptr;
#endif // TEST_PTR_ACCESS

    /*
     * число байт, которым задётся шаг инкремента и декремента
     * для текущей выделенной памяти
     */
    unsigned int iter_step;

} track_ptr_t;




/*
 * функция возвращает последнюю произошедшую ошибку errtrack
 *      и сбрасывает значение этой переменной
 */
extern int track_error(void);

/*
 * функция возвращает сообщение соответствующее ошибке errnum,
 * @errnum: значение полученое из функции track_last_error
 */
extern const char *track_str_error(int errnum);


/*
 * функция инициализирует структуры и переменные,
 *      необходимые для работы библиотеки
 * вернёт:
 *       0 в случае успеха
 *      -1 в случае какой-либо ошибки (код ошибки смотерть в errtrack)
 */
extern int track_init(void);


/*
 * функция очищает структуры и переменные (освобождает память),
 *      которые были необходимы во время работы библиотеки
 * вернёт:
 *       0 в случае успеха
 *      -1 в случае какой-либо ошибки (код ошибки смотерть в errtrack)
 */
extern int track_destroy(void);


/*
 * выделения памяти размером msize байт
 *      и инициализация структуры track_ptr_t
 * @msize: количество байт для выделения
 * @flags: битовые поля отвечающие за
 *      варианты работы с выделенной памятью
 * вернёт:
 *       track_ptr_t * указатель на пользовательскую структуру в случае успеха
 *       NULL в случае какой-либо ошибки (код ошибки смотерть в errtrack)
 */
extern track_ptr_t *track_malloc(size_t msize, int flags);


extern track_ptr_t *track_calloc(size_t nmemb, size_t msize, int flags);


/*
 * функция очищает выделенную по запросу пользователя память
 *      а также очищает память выделенную под управляющие структуры
 *      в том числе под переданную ptrack
 * @ptrack: указатель на пользовательскую структуру данных,
 *      через которую осуществляется управление выделенной памятью
 * вернёт:
 *       0 в случае успеха
 *      -1 в случае какой-либо ошибки (код ошибки смотерть в errtrack)
 */
extern int track_free(track_ptr_t *ptrack);

/*
 * функция пересчитывает контрольную сумму текущей выделенной памяти
 * @ptrack: указатель на пользовательскую структуру данных,
 *      через которую осуществляется управление выделенной памятью
 * вернёт:
 *       0 в случае успеха
 *      -1 в случае какой-либо ошибки (код ошибки смотерть в errtrack)
 */
extern int track_overwrite_checksum(track_ptr_t *ptrack);

/*
 * функция проверяет память на все возможные ошибки
 *      в соответствии с флагами, с которыми она была выделена
 * @ptrack: указатель на пользовательскую структуру данных,
 *      через которую осуществляется управление выделенной памятью
 * вернёт:
 *       1 если в какой-то из проверок произошла ошибка
 *       0 если все проверки прошли бех ошибок
 *      -1 в случае ошибки в функции (код ошибки смотерть в errtrack)
 */
extern int track_check_mem(track_ptr_t *ptrack);

/*
 *  функция смещает указатель на выделенную память на nmove байт
 *      nmove может быть как положительным (перемещает вперёд указатель),
 *      так и отрицательным (сдвигаем назад)
 *      все действие производятся относительно текущего адреса,
 *      на который указывает указатель
 *  @ptrack: указатель на пользовательскую структуру данных,
 *     через которую осуществляется управление выделенной памятью
 * вернёт:
 *       0 в случае успеха
 *      -1 в случае какой-либо ошибки (код ошибки смотерть в errtrack)
 */
extern int track_ptr_move(track_ptr_t *ptrack, long int nmove);


extern int get_offset();


/*
 * функция работает как memset, только проверяет, перекрывается память или нет,
 *      если перекрывается, вернёт ошибку
 * @dest: указатуль на структуру track_ptr_t, содержащую память,
 *      в которую трбуется скопировать
 * @src: указатуль на структуру track_ptr_t, содержащую память,
 *      из которой трбуется скопировать
 * @n: число байт, которые требуется скопировать
 * вернёт:
 *       0 в случае успеха
 *      -1 в случае какой-либо ошибки (код ошибки смотерть в errtrack)
 */
extern int track_memcpy(track_ptr_t *dest, const track_ptr_t *src, size_t n);


#endif /* TRACKPTR_H */
